# GroupChatOrchestration æ–°æ¶æ„æ·±åº¦åˆ†æï¼šGroupChatManager çš„å¼•å…¥

## ğŸ¯ é‡è¦å‘ç°

é€šè¿‡æºä»£ç åˆ†æå‘ç°ï¼Œ`GroupChatOrchestration` ä¸ä»…ä»…æ˜¯ `AgentGroupChat` çš„ç®€å•æ›¿ä»£ï¼Œè€Œæ˜¯å¼•å…¥äº†å…¨æ–°çš„æ¶æ„è®¾è®¡ï¼Œå…¶ä¸­æœ€é‡è¦çš„æ˜¯ **`GroupChatManager`** æ¦‚å¿µçš„å¼•å…¥ã€‚

## ğŸ—ï¸ æ–°æ¶æ„ç»„ä»¶

### 1. GroupChatManagerï¼ˆç¾¤èŠç®¡ç†å™¨ï¼‰

è¿™æ˜¯ `GroupChatOrchestration` çš„æ ¸å¿ƒæ–°å¢ç»„ä»¶ï¼Œè´Ÿè´£ç®¡ç†æ•´ä¸ªç¾¤èŠçš„æµç¨‹ï¼š

```python
@experimental
class GroupChatManager(KernelBaseModel, ABC):
    """A group chat manager that manages the flow of a group chat."""

    current_round: int = 0
    max_rounds: int | None = None
    human_response_function: Callable[[ChatHistory], Awaitable[ChatMessageContent] | ChatMessageContent] | None = None

    @abstractmethod
    async def should_request_user_input(self, chat_history: ChatHistory) -> BooleanResult:
        """æ£€æŸ¥ç¾¤èŠæ˜¯å¦åº”è¯¥è¯·æ±‚ç”¨æˆ·è¾“å…¥"""
        ...

    async def should_terminate(self, chat_history: ChatHistory) -> BooleanResult:
        """æ£€æŸ¥ç¾¤èŠæ˜¯å¦åº”è¯¥ç»ˆæ­¢"""
        ...

    @abstractmethod
    async def select_next_agent(
        self,
        chat_history: ChatHistory,
        participant_descriptions: dict[str, str],
    ) -> StringResult:
        """é€‰æ‹©ä¸‹ä¸€ä¸ªå‘è¨€çš„Agent"""
        ...

    @abstractmethod
    async def filter_results(
        self,
        chat_history: ChatHistory,
    ) -> MessageResult:
        """è¿‡æ»¤ç¾¤èŠç»“æœ"""
        ...
```

### 2. å†…ç½®å®ç°ï¼šRoundRobinGroupChatManager

å®˜æ–¹æä¾›äº†ä¸€ä¸ªé»˜è®¤çš„è½®è¯¢å®ç°ï¼š

```python
@experimental
class RoundRobinGroupChatManager(GroupChatManager):
    """A round-robin group chat manager."""

    current_index: int = 0

    @override
    async def should_request_user_input(self, chat_history: ChatHistory) -> BooleanResult:
        """é»˜è®¤ä¸è¯·æ±‚ç”¨æˆ·è¾“å…¥"""
        return BooleanResult(
            result=False,
            reason="The default round-robin group chat manager does not request user input.",
        )

    @override
    async def select_next_agent(
        self,
        chat_history: ChatHistory,
        participant_descriptions: dict[str, str],
    ) -> StringResult:
        """è½®è¯¢é€‰æ‹©ä¸‹ä¸€ä¸ªAgent"""
        next_agent = list(participant_descriptions.keys())[self.current_index]
        self.current_index = (self.current_index + 1) % len(participant_descriptions)
        return StringResult(result=next_agent, reason="Round-robin selection.")

    @override
    async def filter_results(
        self,
        chat_history: ChatHistory,
    ) -> MessageResult:
        """è¿”å›æœ€åä¸€æ¡æ¶ˆæ¯ä½œä¸ºç»“æœ"""
        return MessageResult(
            result=chat_history.messages[-1],
            reason="The last message in the chat history is the result in the default round-robin group chat manager.",
        )
```

## ğŸ”„ æ¶æ„å¯¹æ¯”

### AgentGroupChatï¼ˆæ—§æ¶æ„ï¼‰
```
AgentGroupChat
â”œâ”€â”€ SelectionStrategyï¼ˆé€‰æ‹©ç­–ç•¥ï¼‰
â”œâ”€â”€ TerminationStrategyï¼ˆç»ˆæ­¢ç­–ç•¥ï¼‰
â””â”€â”€ Agentsï¼ˆä»£ç†åˆ—è¡¨ï¼‰
```

### GroupChatOrchestrationï¼ˆæ–°æ¶æ„ï¼‰
```
GroupChatOrchestration
â”œâ”€â”€ GroupChatManagerï¼ˆç¾¤èŠç®¡ç†å™¨ï¼‰
â”‚   â”œâ”€â”€ should_request_user_input()
â”‚   â”œâ”€â”€ should_terminate()
â”‚   â”œâ”€â”€ select_next_agent()
â”‚   â””â”€â”€ filter_results()
â”œâ”€â”€ GroupChatManagerActorï¼ˆç®¡ç†å™¨æ‰§è¡Œè€…ï¼‰
â”œâ”€â”€ GroupChatAgentActorï¼ˆä»£ç†æ‰§è¡Œè€…ï¼‰
â””â”€â”€ Membersï¼ˆæˆå‘˜åˆ—è¡¨ï¼‰
```

## ğŸ“Š åŠŸèƒ½å¯¹æ¯”

| åŠŸèƒ½ | AgentGroupChat | GroupChatOrchestration |
|------|----------------|----------------------|
| **Agenté€‰æ‹©** | SelectionStrategy | GroupChatManager.select_next_agent() |
| **ç»ˆæ­¢æ§åˆ¶** | TerminationStrategy | GroupChatManager.should_terminate() |
| **ç”¨æˆ·äº¤äº’** | é€šè¿‡UserAgent | GroupChatManager.should_request_user_input() |
| **ç»“æœè¿‡æ»¤** | æ‰‹åŠ¨å¤„ç† | GroupChatManager.filter_results() |
| **è½®æ•°æ§åˆ¶** | åœ¨TerminationStrategyä¸­ | GroupChatManager.max_rounds |
| **äººå·¥å¹²é¢„** | æ— å†…ç½®æ”¯æŒ | GroupChatManager.human_response_function |

## ğŸ†• æ–°å¢åŠŸèƒ½

### 1. å†…ç½®è½®æ•°æ§åˆ¶
```python
# å¯ä»¥ç›´æ¥è®¾ç½®æœ€å¤§è½®æ•°
manager = RoundRobinGroupChatManager()
manager.max_rounds = 10  # æœ€å¤š10è½®å¯¹è¯
```

### 2. äººå·¥å¹²é¢„æœºåˆ¶
```python
async def human_input_handler(chat_history: ChatHistory) -> ChatMessageContent:
    # è‡ªå®šä¹‰äººå·¥è¾“å…¥é€»è¾‘
    user_input = input("è¯·è¾“å…¥æ‚¨çš„æ„è§: ")
    return ChatMessageContent(role=AuthorRole.USER, content=user_input)

manager.human_response_function = human_input_handler
```

### 3. æ™ºèƒ½ç»“æœè¿‡æ»¤
```python
# å¯ä»¥è‡ªå®šä¹‰ç»“æœè¿‡æ»¤é€»è¾‘
class CustomGroupChatManager(GroupChatManager):
    async def filter_results(self, chat_history: ChatHistory) -> MessageResult:
        # è‡ªå®šä¹‰è¿‡æ»¤é€»è¾‘ï¼Œæ¯”å¦‚é€‰æ‹©è´¨é‡æœ€é«˜çš„å›å¤
        best_message = self.select_best_message(chat_history.messages)
        return MessageResult(result=best_message, reason="Selected best quality message")
```

## ğŸ”§ ä½¿ç”¨ç¤ºä¾‹

### åŸºç¡€ç”¨æ³•ï¼ˆä½¿ç”¨é»˜è®¤è½®è¯¢ç®¡ç†å™¨ï¼‰
```python
from semantic_kernel.agents.orchestration.group_chat import (
    GroupChatOrchestration, 
    RoundRobinGroupChatManager
)

# åˆ›å»ºè½®è¯¢ç®¡ç†å™¨
manager = RoundRobinGroupChatManager()
manager.max_rounds = 5

# åˆ›å»ºç¾¤èŠç¼–æ’
group_chat = GroupChatOrchestration(
    members=[agent1, agent2, agent3],
    manager=manager
)

result = await group_chat.invoke("è¯·åä½œå®Œæˆä»»åŠ¡")
```

### é«˜çº§ç”¨æ³•ï¼ˆè‡ªå®šä¹‰ç®¡ç†å™¨ï¼‰
```python
class IntelligentGroupChatManager(GroupChatManager):
    """æ™ºèƒ½ç¾¤èŠç®¡ç†å™¨"""
    
    def __init__(self, ai_service):
        super().__init__()
        self.ai_service = ai_service
        self.max_rounds = 10
    
    async def should_request_user_input(self, chat_history: ChatHistory) -> BooleanResult:
        # åŸºäºå¯¹è¯å†…å®¹æ™ºèƒ½åˆ¤æ–­æ˜¯å¦éœ€è¦ç”¨æˆ·è¾“å…¥
        if len(chat_history.messages) > 5:
            last_messages = chat_history.messages[-3:]
            # ä½¿ç”¨AIåˆ¤æ–­æ˜¯å¦éœ€è¦ç”¨æˆ·æ¾„æ¸…
            need_input = await self._ai_judge_need_user_input(last_messages)
            return BooleanResult(result=need_input, reason="AI-based decision")
        return BooleanResult(result=False, reason="Not enough context")
    
    async def select_next_agent(
        self, 
        chat_history: ChatHistory, 
        participant_descriptions: dict[str, str]
    ) -> StringResult:
        # åŸºäºå¯¹è¯å†…å®¹å’ŒAgentèƒ½åŠ›æ™ºèƒ½é€‰æ‹©
        context = self._analyze_conversation_context(chat_history)
        best_agent = await self._ai_select_best_agent(context, participant_descriptions)
        return StringResult(result=best_agent, reason="AI-powered selection")
    
    async def filter_results(self, chat_history: ChatHistory) -> MessageResult:
        # æ™ºèƒ½ç­›é€‰æœ€ä½³ç»“æœ
        final_message = await self._ai_synthesize_results(chat_history.messages)
        return MessageResult(result=final_message, reason="AI-synthesized result")

# ä½¿ç”¨è‡ªå®šä¹‰ç®¡ç†å™¨
intelligent_manager = IntelligentGroupChatManager(ai_service)
group_chat = GroupChatOrchestration(
    members=[content_agent, code_agent, user_agent],
    manager=intelligent_manager
)
```

## ğŸ¯ è¿ç§»ç­–ç•¥æ›´æ–°

åŸºäºæ–°å‘ç°çš„æ¶æ„ï¼Œè¿ç§»ç­–ç•¥éœ€è¦æ›´æ–°ï¼š

### æ—§ç‰ˆè¿ç§»æ–¹å¼ï¼ˆä¸å®Œæ•´ï¼‰
```python
# ç®€å•çš„ç±»åæ›¿æ¢ï¼ˆä¸å……åˆ†ï¼‰
group_chat = GroupChatOrchestration(
    agents=agents,
    selection_strategy=CustomSelectionStrategy(),  # è¿™ç§æ–¹å¼ä¸é€‚ç”¨
    termination_strategy=CustomTerminationStrategy()  # è¿™ç§æ–¹å¼ä¸é€‚ç”¨
)
```

### æ­£ç¡®çš„è¿ç§»æ–¹å¼
```python
# 1. åˆ›å»ºæˆ–é€‰æ‹©åˆé€‚çš„GroupChatManager
if need_simple_round_robin:
    manager = RoundRobinGroupChatManager()
    manager.max_rounds = 10
else:
    # åˆ›å»ºè‡ªå®šä¹‰ç®¡ç†å™¨ï¼Œæ•´åˆåŸæœ‰çš„é€‰æ‹©å’Œç»ˆæ­¢é€»è¾‘
    manager = CustomGroupChatManager(
        selection_logic=original_selection_strategy,
        termination_logic=original_termination_strategy
    )

# 2. ä½¿ç”¨æ–°æ¶æ„
group_chat = GroupChatOrchestration(
    members=agents,  # æ³¨æ„ï¼šå‚æ•°åä»agentsæ”¹ä¸ºmembers
    manager=manager
)
```

## ğŸ† æ¶æ„ä¼˜åŠ¿

### 1. æ›´æ¸…æ™°çš„èŒè´£åˆ†ç¦»
- **GroupChatManager**: ä¸“æ³¨äºæµç¨‹æ§åˆ¶
- **GroupChatManagerActor**: ä¸“æ³¨äºæ¶ˆæ¯å¤„ç†
- **GroupChatAgentActor**: ä¸“æ³¨äºAgentæ‰§è¡Œ

### 2. æ›´å¼ºçš„æ‰©å±•æ€§
- å¯ä»¥è½»æ¾å®ç°ä¸åŒçš„ç®¡ç†ç­–ç•¥
- æ”¯æŒå¤æ‚çš„äº¤äº’æ¨¡å¼
- å†…ç½®äººå·¥å¹²é¢„æœºåˆ¶

### 3. æ›´å¥½çš„å¯ç»´æŠ¤æ€§
- æ¸…æ™°çš„æ¥å£å®šä¹‰
- æ¨¡å—åŒ–çš„è®¾è®¡
- æ˜“äºæµ‹è¯•å’Œè°ƒè¯•

## ğŸ”® è‡ªå®šä¹‰GroupChatManagerç¤ºä¾‹

```python
class ProjectManagementChatManager(GroupChatManager):
    """é¡¹ç›®ç®¡ç†ç¾¤èŠç®¡ç†å™¨"""
    
    def __init__(self):
        super().__init__()
        self.max_rounds = 20
        self.phase = "planning"  # planning, development, review, completion
    
    async def select_next_agent(
        self, 
        chat_history: ChatHistory, 
        participant_descriptions: dict[str, str]
    ) -> StringResult:
        """æ ¹æ®é¡¹ç›®é˜¶æ®µé€‰æ‹©åˆé€‚çš„Agent"""
        if self.phase == "planning":
            return StringResult(result="ProjectManagerAgent", reason="Planning phase")
        elif self.phase == "development":
            return StringResult(result="DeveloperAgent", reason="Development phase")
        elif self.phase == "review":
            return StringResult(result="ReviewerAgent", reason="Review phase")
        else:
            return StringResult(result="ProjectManagerAgent", reason="Default to manager")
    
    async def should_terminate(self, chat_history: ChatHistory) -> BooleanResult:
        """åŸºäºé¡¹ç›®å®Œæˆåº¦åˆ¤æ–­æ˜¯å¦ç»ˆæ­¢"""
        if self.phase == "completion":
            return BooleanResult(result=True, reason="Project completed")
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ¢é˜¶æ®µ
        last_message = chat_history.messages[-1].content if chat_history.messages else ""
        if "planning complete" in last_message.lower():
            self.phase = "development"
        elif "development complete" in last_message.lower():
            self.phase = "review"
        elif "review complete" in last_message.lower():
            self.phase = "completion"
        
        return await super().should_terminate(chat_history)
```

## ğŸ“‹ æ›´æ–°åçš„è¿ç§»æ£€æŸ¥æ¸…å•

- [ ] **äº†è§£æ–°æ¶æ„**: ç†è§£ GroupChatManager çš„ä½œç”¨å’Œè®¾è®¡
- [ ] **é€‰æ‹©ç®¡ç†å™¨**: å†³å®šä½¿ç”¨ RoundRobinGroupChatManager è¿˜æ˜¯è‡ªå®šä¹‰
- [ ] **è¿ç§»é€‰æ‹©é€»è¾‘**: å°† SelectionStrategy é€»è¾‘è¿ç§»åˆ° select_next_agent()
- [ ] **è¿ç§»ç»ˆæ­¢é€»è¾‘**: å°† TerminationStrategy é€»è¾‘è¿ç§»åˆ° should_terminate()
- [ ] **æ›´æ–°å‚æ•°å**: agents â†’ members
- [ ] **æµ‹è¯•æ–°åŠŸèƒ½**: éªŒè¯è½®æ•°æ§åˆ¶ã€ç”¨æˆ·äº¤äº’ã€ç»“æœè¿‡æ»¤ç­‰æ–°åŠŸèƒ½
- [ ] **æ€§èƒ½å¯¹æ¯”**: å¯¹æ¯”æ–°æ—§æ¶æ„çš„æ€§èƒ½å·®å¼‚

## ğŸ‰ æ€»ç»“

`GroupChatOrchestration` çš„å¼•å…¥ä¸ä»…ä»…æ˜¯ API çš„ç®€åŒ–ï¼Œæ›´æ˜¯æ¶æ„çš„é‡å¤§å‡çº§ï¼š

1. **å¼•å…¥ GroupChatManager**: ç»Ÿä¸€ç®¡ç†ç¾¤èŠæµç¨‹çš„å„ä¸ªæ–¹é¢
2. **æä¾›é»˜è®¤å®ç°**: RoundRobinGroupChatManager å¼€ç®±å³ç”¨
3. **æ”¯æŒæ·±åº¦è‡ªå®šä¹‰**: å¯ä»¥å®ç°å¤æ‚çš„ç¾¤èŠç®¡ç†é€»è¾‘
4. **å†…ç½®é«˜çº§åŠŸèƒ½**: äººå·¥å¹²é¢„ã€ç»“æœè¿‡æ»¤ã€è½®æ•°æ§åˆ¶ç­‰

è¿™ä¸ªæ–°æ¶æ„ä¸ºå¤æ‚çš„å¤šAgentåä½œæä¾›äº†æ›´å¼ºå¤§å’Œçµæ´»çš„åŸºç¡€æ¡†æ¶ã€‚
