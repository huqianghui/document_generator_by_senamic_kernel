# Semantic Kernel é€‰æ‹©ç­–ç•¥åˆ†æä¸æ¡†æ¶å¯¹æ¯”

## ğŸ“‹ ç›®å½•
- [1. æ¦‚è¿°](#1-æ¦‚è¿°)
- [2. Semantic Kernel é€‰æ‹©ç­–ç•¥ç°çŠ¶](#2-semantic-kernel-é€‰æ‹©ç­–ç•¥ç°çŠ¶)
- [3. ä¸å…¶ä»–æ¡†æ¶å¯¹æ¯”](#3-ä¸å…¶ä»–æ¡†æ¶å¯¹æ¯”)
- [4. ä¼˜åŠ¿ä¸ä¸è¶³åˆ†æ](#4-ä¼˜åŠ¿ä¸ä¸è¶³åˆ†æ)
- [5. æ”¹è¿›å»ºè®®](#5-æ”¹è¿›å»ºè®®)
- [6. å®é™…åº”ç”¨ç¤ºä¾‹](#6-å®é™…åº”ç”¨ç¤ºä¾‹)
- [7. æ€»ç»“](#7-æ€»ç»“)

---

## 1. æ¦‚è¿°

åœ¨å¤šAgentåä½œç³»ç»Ÿä¸­ï¼Œé€‰æ‹©ç­–ç•¥ï¼ˆSelection Strategyï¼‰æ˜¯å†³å®šä¸‹ä¸€ä¸ªåº”è¯¥æ¿€æ´»å“ªä¸ªAgentçš„æ ¸å¿ƒæœºåˆ¶ã€‚ä¸åŒçš„æ¡†æ¶æä¾›äº†ä¸åŒçš„é€‰æ‹©ç­–ç•¥å®ç°æ–¹å¼ï¼Œä»ç®€å•çš„è½®è¯¢åˆ°å¤æ‚çš„AIé©±åŠ¨é€‰æ‹©ã€‚

æœ¬æ–‡æ¡£æ·±å…¥åˆ†æäº† Semantic Kernel çš„é€‰æ‹©ç­–ç•¥ç°çŠ¶ï¼Œå¹¶ä¸ AutoGenã€CrewAI ç­‰ä¸»æµæ¡†æ¶è¿›è¡Œäº†è¯¦ç»†å¯¹æ¯”ã€‚

---

## 2. Semantic Kernel é€‰æ‹©ç­–ç•¥ç°çŠ¶

### 2.1 åŸºç¡€æ¶æ„

```python
@experimental
class SelectionStrategy(KernelBaseModel, ABC):
    """Base strategy class for selecting the next agent in a chat."""
    
    has_selected: bool = False
    initial_agent: Agent | None = None
    
    async def next(self, agents: list[Agent], history: list["ChatMessageContent"]) -> Agent:
        """Select the next agent to interact with."""
        # åŸºç¡€é€‰æ‹©é€»è¾‘
        
    async def select_agent(self, agents: list[Agent], history: list["ChatMessageContent"]) -> Agent:
        """Determines which agent goes next. Override for custom logic."""
        # é»˜è®¤è¿”å›ç¬¬ä¸€ä¸ªAgent
        return agents[0]
```

### 2.2 ç°æœ‰é€‰æ‹©ç­–ç•¥

#### 2.2.1 SequentialSelectionStrategyï¼ˆé¡ºåºé€‰æ‹©ï¼‰

```python
@experimental
class SequentialSelectionStrategy(SelectionStrategy):
    """Round-robin turn-taking strategy. Agent order is based on the order in which they joined."""
    
    _index: int = PrivateAttr(default=-1)
    
    async def select_agent(self, agents: list["Agent"], history: list["ChatMessageContent"]) -> "Agent":
        """æŒ‰è½®è¯¢æ–¹å¼é€‰æ‹©ä¸‹ä¸€ä¸ªAgent"""
        if self._index >= len(agents):
            self._index = -1
        
        self._increment_index(len(agents))
        return agents[self._index]
```

**ç‰¹ç‚¹ï¼š**
- âœ… **å¼€ç®±å³ç”¨**ï¼šæ— éœ€ç¼–å†™ä»»ä½•ä»£ç 
- âœ… **å…¬å¹³è½®è¯¢**ï¼šæ¯ä¸ªAgentéƒ½æœ‰ç›¸ç­‰çš„æœºä¼š
- âœ… **ç®€å•å¯é **ï¼šé€»è¾‘æ¸…æ™°ï¼Œä¸ä¼šå‡ºé”™
- âœ… **å¯é‡ç½®**ï¼šæ”¯æŒé‡ç½®åˆ°åˆå§‹çŠ¶æ€
- âŒ **ç¼ºä¹æ™ºèƒ½**ï¼šä¸è€ƒè™‘å¯¹è¯ä¸Šä¸‹æ–‡
- âŒ **æ•ˆç‡è¾ƒä½**ï¼šå¯èƒ½é€‰æ‹©ä¸åˆé€‚çš„Agent

#### 2.2.2 KernelFunctionSelectionStrategyï¼ˆå‡½æ•°é€‰æ‹©ï¼‰

```python
@experimental
class KernelFunctionSelectionStrategy(SelectionStrategy):
    """Determines agent selection based on the evaluation of a Kernel Function."""
    
    DEFAULT_AGENT_VARIABLE_NAME: ClassVar[str] = "_agent_"
    DEFAULT_HISTORY_VARIABLE_NAME: ClassVar[str] = "_history_"
    
    function: KernelFunction  # å¿…é¡»ç”±ç”¨æˆ·æä¾›
    kernel: Kernel           # å¿…é¡»ç”±ç”¨æˆ·æä¾›
    result_parser: Callable[..., str]
    
    async def select_agent(self, agents: list["Agent"], history: list[ChatMessageContent]) -> "Agent":
        """åŸºäºKernelå‡½æ•°æ‰§è¡Œç»“æœé€‰æ‹©Agent"""
        # å‡†å¤‡å‡½æ•°å‚æ•°
        arguments = KernelArguments(
            **{
                self.agent_variable_name: ",".join(agent.name for agent in agents),
                self.history_variable_name: [msg.to_dict() for msg in history],
            }
        )
        
        # æ‰§è¡Œå‡½æ•°
        result = await self.function.invoke(kernel=self.kernel, arguments=arguments)
        
        # è§£æç»“æœ
        agent_name = self.result_parser(result)
        return next(agent for agent in agents if agent.name == agent_name)
```

**ç‰¹ç‚¹ï¼š**
- âœ… **é«˜åº¦å¯å®šåˆ¶**ï¼šå®Œå…¨ç”±ç”¨æˆ·æ§åˆ¶é€‰æ‹©é€»è¾‘
- âœ… **çµæ´»å¼ºå¤§**ï¼šæ”¯æŒå¤æ‚çš„ä¸šåŠ¡é€»è¾‘
- âœ… **é›†æˆè‰¯å¥½**ï¼šå……åˆ†åˆ©ç”¨Kernelå‡½æ•°ç”Ÿæ€
- âŒ **éœ€è¦ç¼–ç **ï¼šç”¨æˆ·å¿…é¡»å®ç°é€‰æ‹©å‡½æ•°
- âŒ **å­¦ä¹ æˆæœ¬é«˜**ï¼šéœ€è¦äº†è§£Kernel Functionæœºåˆ¶

#### 2.2.3 CustomSelectionStrategyï¼ˆè‡ªå®šä¹‰AIé€‰æ‹©ï¼‰

```python
@experimental
class CustomSelectionStrategy(SelectionStrategy):
    """A selection strategy that selects the next agent intelligently."""
    
    NUM_OF_RETRIES: ClassVar[int] = 3
    chat_completion_service: ChatCompletionClientBase
    
    async def next(self, agents: list["Agent"], history: list["ChatMessageContent"]) -> "Agent":
        """ä½¿ç”¨AIæ¨¡å‹æ™ºèƒ½é€‰æ‹©ä¸‹ä¸€ä¸ªAgent"""
        # æ„å»ºå¯¹è¯å†å²
        chat_history = ChatHistory(system_message=self.get_system_message(agents))
        
        # æ·»åŠ å†å²æ¶ˆæ¯
        for message in history:
            if message.content:
                chat_history.add_message(message)
        
        # è¯·æ±‚AIé€‰æ‹©
        chat_history.add_user_message("Now follow the rules and select the next agent by typing the agent's index.")
        
        # é‡è¯•æœºåˆ¶
        for _ in range(self.NUM_OF_RETRIES):
            completion = await self.chat_completion_service.get_chat_message_content(
                chat_history, AzureChatPromptExecutionSettings()
            )
            
            try:
                return agents[int(completion.content)]
            except ValueError:
                # å¤„ç†é”™è¯¯å“åº”
                chat_history.add_message(completion)
                chat_history.add_user_message(f"You must only say a number between 0 and {len(agents) - 1}.")
        
        raise ValueError("Failed to select an agent")
```

**ç‰¹ç‚¹ï¼š**
- âœ… **æ™ºèƒ½å†³ç­–**ï¼šåŸºäºAIæ¨¡å‹çš„ä¸Šä¸‹æ–‡ç†è§£
- âœ… **é€‚åº”æ€§å¼º**ï¼šå¯ä»¥å¤„ç†å¤æ‚çš„å¯¹è¯åœºæ™¯
- âœ… **è‡ªç„¶è¯­è¨€å¤„ç†**ï¼šèƒ½ç†è§£å¯¹è¯è¯­ä¹‰
- âŒ **æˆæœ¬è¾ƒé«˜**ï¼šæ¯æ¬¡é€‰æ‹©éƒ½éœ€è¦è°ƒç”¨AIæ¨¡å‹
- âŒ **å»¶è¿Ÿé—®é¢˜**ï¼šç½‘ç»œè°ƒç”¨å¢åŠ å“åº”æ—¶é—´
- âŒ **å¯é æ€§ä¾èµ–**ï¼šä¾èµ–AIæ¨¡å‹çš„ç¨³å®šæ€§

---

## 3. ä¸å…¶ä»–æ¡†æ¶å¯¹æ¯”

### 3.1 AutoGen é€‰æ‹©ç­–ç•¥

AutoGen æä¾›äº†å¤šç§å†…ç½®çš„é€‰æ‹©ç­–ç•¥ï¼š

#### 3.1.1 è‡ªåŠ¨é€‰æ‹©ï¼ˆé»˜è®¤ï¼‰
```python
groupchat = autogen.GroupChat(
    agents=[agent1, agent2, agent3],
    messages=[],
    max_round=10,
    # é»˜è®¤ä½¿ç”¨æ™ºèƒ½é€‰æ‹©ï¼Œæ ¹æ®å¯¹è¯å†…å®¹è‡ªåŠ¨é€‰æ‹©ä¸‹ä¸€ä¸ªAgent
)
```

#### 3.1.2 æ‰‹åŠ¨é€‰æ‹©
```python
groupchat = autogen.GroupChat(
    agents=[agent1, agent2, agent3],
    messages=[],
    max_round=10,
    speaker_selection_method="manual",  # æ‰‹åŠ¨é€‰æ‹©
)
```

#### 3.1.3 è½®è¯¢é€‰æ‹©
```python
groupchat = autogen.GroupChat(
    agents=[agent1, agent2, agent3],
    messages=[],
    max_round=10,
    speaker_selection_method="round_robin",  # è½®è¯¢é€‰æ‹©
)
```

#### 3.1.4 éšæœºé€‰æ‹©
```python
groupchat = autogen.GroupChat(
    agents=[agent1, agent2, agent3],
    messages=[],
    max_round=10,
    speaker_selection_method="random",  # éšæœºé€‰æ‹©
)
```

#### 3.1.5 è‡ªå®šä¹‰é€‰æ‹©å‡½æ•°
```python
def custom_speaker_selection(last_speaker, groupchat):
    """è‡ªå®šä¹‰é€‰æ‹©é€»è¾‘"""
    last_message = groupchat.messages[-1]["content"]
    
    if "code" in last_message.lower():
        return "CodeReviewAgent"
    elif "design" in last_message.lower():
        return "DesignAgent"
    else:
        return "ContentAgent"

groupchat = autogen.GroupChat(
    agents=[agent1, agent2, agent3],
    messages=[],
    max_round=10,
    speaker_selection_method=custom_speaker_selection,
)
```

### 3.2 CrewAI é€‰æ‹©ç­–ç•¥

CrewAI æä¾›äº†ä»»åŠ¡å¯¼å‘çš„é€‰æ‹©ç­–ç•¥ï¼š

#### 3.2.1 é¡ºåºæ‰§è¡Œ
```python
from crewai import Crew, Process

crew = Crew(
    agents=[agent1, agent2, agent3],
    tasks=[task1, task2, task3],
    process=Process.sequential,  # é¡ºåºæ‰§è¡Œä»»åŠ¡
)
```

#### 3.2.2 å±‚çº§æ‰§è¡Œ
```python
crew = Crew(
    agents=[manager, developer, tester],
    tasks=[planning_task, dev_task, test_task],
    process=Process.hierarchical,  # å±‚çº§æ‰§è¡Œï¼Œæœ‰ç®¡ç†è€…
    manager_llm=manager_llm,
)
```

#### 3.2.3 å¹¶å‘æ‰§è¡Œ
```python
crew = Crew(
    agents=[agent1, agent2, agent3],
    tasks=[task1, task2, task3],
    process=Process.parallel,  # å¹¶å‘æ‰§è¡Œ
)
```

### 3.3 LangGraph é€‰æ‹©ç­–ç•¥

LangGraph åŸºäºå›¾ç»“æ„çš„é€‰æ‹©ç­–ç•¥ï¼š

```python
from langgraph.graph import StateGraph, MessageGraph

# å®šä¹‰çŠ¶æ€è½¬æ¢å›¾
workflow = StateGraph(AgentState)

# æ·»åŠ èŠ‚ç‚¹
workflow.add_node("researcher", research_agent)
workflow.add_node("writer", writer_agent)
workflow.add_node("reviewer", reviewer_agent)

# å®šä¹‰è¾¹å’Œæ¡ä»¶
workflow.add_conditional_edges(
    "researcher",
    lambda state: "writer" if state.research_complete else "researcher"
)

workflow.add_conditional_edges(
    "writer",
    lambda state: "reviewer" if state.draft_complete else "writer"
)

# ç¼–è¯‘å›¾
app = workflow.compile()
```

---

## 4. ä¼˜åŠ¿ä¸ä¸è¶³åˆ†æ

### 4.1 Semantic Kernel ä¼˜åŠ¿

#### 4.1.1 é«˜åº¦å¯å®šåˆ¶åŒ–
- **KernelFunctionSelectionStrategy** å…è®¸ç”¨æˆ·å®ç°ä»»æ„å¤æ‚çš„é€‰æ‹©é€»è¾‘
- å……åˆ†åˆ©ç”¨ Kernel å‡½æ•°ç”Ÿæ€ç³»ç»Ÿ
- æ”¯æŒæ’ä»¶åŒ–æ‰©å±•

#### 4.1.2 AIåŸç”Ÿè®¾è®¡
- **CustomSelectionStrategy** å±•ç¤ºäº†AIé©±åŠ¨é€‰æ‹©çš„èƒ½åŠ›
- è‡ªç„¶è¯­è¨€ç†è§£å’Œæ¨ç†
- ä¸Šä¸‹æ–‡æ„ŸçŸ¥é€‰æ‹©

#### 4.1.3 æ¶æ„ä¼˜é›…
- åŸºäºæŠ½è±¡ç±»çš„è®¾è®¡æ¨¡å¼
- æ¸…æ™°çš„æ¥å£å®šä¹‰
- æ˜“äºæ‰©å±•å’Œç»´æŠ¤

### 4.2 Semantic Kernel ä¸è¶³

#### 4.2.1 å¼€ç®±å³ç”¨ç­–ç•¥å°‘
- åªæœ‰ **SequentialSelectionStrategy** æ— éœ€ç¼–ç 
- ç¼ºä¹å¸¸è§çš„é€‰æ‹©ç­–ç•¥æ¨¡æ¿
- å­¦ä¹ æ›²çº¿ç›¸å¯¹é™¡å³­

#### 4.2.2 ç¼ºä¹å¸¸ç”¨æ¨¡å¼
- æ²¡æœ‰ä¼˜å…ˆçº§é€‰æ‹©ç­–ç•¥
- ç¼ºä¹åŸºäºè§„åˆ™çš„é€‰æ‹©ç­–ç•¥
- æ²¡æœ‰çŠ¶æ€æœºé€‰æ‹©ç­–ç•¥

#### 4.2.3 æ–‡æ¡£å’Œç¤ºä¾‹ä¸è¶³
- é€‰æ‹©ç­–ç•¥çš„æ–‡æ¡£ç›¸å¯¹è¾ƒå°‘
- ç¼ºä¹æœ€ä½³å®è·µæŒ‡å—
- ç¤ºä¾‹ä»£ç ä¸å¤Ÿä¸°å¯Œ

### 4.3 æ¡†æ¶å¯¹æ¯”æ€»ç»“

| ç‰¹æ€§ | Semantic Kernel | AutoGen | CrewAI | LangGraph |
|------|----------------|---------|---------|-----------|
| **å¼€ç®±å³ç”¨ç­–ç•¥** | â­â­ | â­â­â­â­â­ | â­â­â­â­ | â­â­â­ |
| **å®šåˆ¶åŒ–èƒ½åŠ›** | â­â­â­â­â­ | â­â­â­ | â­â­â­ | â­â­â­â­â­ |
| **AIé›†æˆ** | â­â­â­â­â­ | â­â­â­â­ | â­â­â­ | â­â­â­ |
| **å­¦ä¹ æˆæœ¬** | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ | â­â­ |
| **æ€§èƒ½** | â­â­â­â­ | â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| **æ–‡æ¡£è´¨é‡** | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ | â­â­â­â­ |

---

## 5. æ”¹è¿›å»ºè®®

### 5.1 å¢åŠ å†…ç½®é€‰æ‹©ç­–ç•¥

#### 5.1.1 åŸºäºè§„åˆ™çš„é€‰æ‹©ç­–ç•¥
```python
class RuleBasedSelectionStrategy(SelectionStrategy):
    """åŸºäºè§„åˆ™çš„é€‰æ‹©ç­–ç•¥"""
    
    def __init__(self, rules: dict[str, str]):
        """
        Args:
            rules: å…³é”®è¯åˆ°Agentåç§°çš„æ˜ å°„
        """
        self.rules = rules
    
    async def select_agent(self, agents: list["Agent"], history: list["ChatMessageContent"]) -> "Agent":
        if not history:
            return agents[0]
        
        last_message = history[-1].content.lower()
        
        for keyword, agent_name in self.rules.items():
            if keyword in last_message:
                agent = next((a for a in agents if a.name == agent_name), None)
                if agent:
                    return agent
        
        return agents[0]  # é»˜è®¤é€‰æ‹©

# ä½¿ç”¨ç¤ºä¾‹
strategy = RuleBasedSelectionStrategy({
    "code": "CodeValidationAgent",
    "design": "DesignAgent",
    "review": "ReviewAgent"
})
```

#### 5.1.2 ä¼˜å…ˆçº§é€‰æ‹©ç­–ç•¥
```python
class PrioritySelectionStrategy(SelectionStrategy):
    """ä¼˜å…ˆçº§é€‰æ‹©ç­–ç•¥"""
    
    def __init__(self, priorities: dict[str, int]):
        """
        Args:
            priorities: Agentåç§°åˆ°ä¼˜å…ˆçº§çš„æ˜ å°„ï¼Œæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
        """
        self.priorities = priorities
    
    async def select_agent(self, agents: list["Agent"], history: list["ChatMessageContent"]) -> "Agent":
        # æŒ‰ä¼˜å…ˆçº§æ’åº
        sorted_agents = sorted(
            agents, 
            key=lambda agent: self.priorities.get(agent.name, 999)
        )
        
        return sorted_agents[0]
```

#### 5.1.3 çŠ¶æ€æœºé€‰æ‹©ç­–ç•¥
```python
class StateMachineSelectionStrategy(SelectionStrategy):
    """çŠ¶æ€æœºé€‰æ‹©ç­–ç•¥"""
    
    def __init__(self, state_transitions: dict[str, dict[str, str]]):
        """
        Args:
            state_transitions: çŠ¶æ€è½¬æ¢è¡¨
        """
        self.state_transitions = state_transitions
        self.current_state = "start"
    
    async def select_agent(self, agents: list["Agent"], history: list["ChatMessageContent"]) -> "Agent":
        # æ ¹æ®å½“å‰çŠ¶æ€å’Œè¾“å…¥ç¡®å®šä¸‹ä¸€ä¸ªçŠ¶æ€
        if history:
            last_message = history[-1].content.lower()
            transitions = self.state_transitions.get(self.current_state, {})
            
            for trigger, next_state in transitions.items():
                if trigger in last_message:
                    self.current_state = next_state
                    break
        
        # æ ¹æ®çŠ¶æ€é€‰æ‹©Agent
        agent_name = self.current_state
        agent = next((a for a in agents if a.name == agent_name), None)
        return agent or agents[0]
```

### 5.2 æä¾›é€‰æ‹©ç­–ç•¥å·¥å‚

```python
class SelectionStrategyFactory:
    """é€‰æ‹©ç­–ç•¥å·¥å‚"""
    
    @staticmethod
    def create_sequential() -> SelectionStrategy:
        """åˆ›å»ºé¡ºåºé€‰æ‹©ç­–ç•¥"""
        return SequentialSelectionStrategy()
    
    @staticmethod
    def create_rule_based(rules: dict[str, str]) -> SelectionStrategy:
        """åˆ›å»ºåŸºäºè§„åˆ™çš„é€‰æ‹©ç­–ç•¥"""
        return RuleBasedSelectionStrategy(rules)
    
    @staticmethod
    def create_priority_based(priorities: dict[str, int]) -> SelectionStrategy:
        """åˆ›å»ºåŸºäºä¼˜å…ˆçº§çš„é€‰æ‹©ç­–ç•¥"""
        return PrioritySelectionStrategy(priorities)
    
    @staticmethod
    def create_ai_powered(
        model_config: dict,
        custom_prompt: str = None
    ) -> SelectionStrategy:
        """åˆ›å»ºAIé©±åŠ¨çš„é€‰æ‹©ç­–ç•¥"""
        return CustomSelectionStrategy(
            chat_completion_service=AzureChatCompletion(**model_config),
            custom_prompt=custom_prompt
        )
    
    @staticmethod
    def create_weighted_random(weights: dict[str, float]) -> SelectionStrategy:
        """åˆ›å»ºåŠ æƒéšæœºé€‰æ‹©ç­–ç•¥"""
        return WeightedRandomSelectionStrategy(weights)
```

### 5.3 æä¾›é€‰æ‹©ç­–ç•¥ç»„åˆå™¨

```python
class CompositeSelectionStrategy(SelectionStrategy):
    """å¤åˆé€‰æ‹©ç­–ç•¥"""
    
    def __init__(self, strategies: list[SelectionStrategy], combination_mode: str = "majority"):
        """
        Args:
            strategies: è¦ç»„åˆçš„ç­–ç•¥åˆ—è¡¨
            combination_mode: ç»„åˆæ¨¡å¼ ('majority', 'weighted', 'cascade')
        """
        self.strategies = strategies
        self.combination_mode = combination_mode
    
    async def select_agent(self, agents: list["Agent"], history: list["ChatMessageContent"]) -> "Agent":
        if self.combination_mode == "majority":
            # å¤šæ•°æŠ•ç¥¨
            votes = {}
            for strategy in self.strategies:
                selected = await strategy.select_agent(agents, history)
                votes[selected.name] = votes.get(selected.name, 0) + 1
            
            # é€‰æ‹©å¾—ç¥¨æœ€å¤šçš„Agent
            winner = max(votes, key=votes.get)
            return next(a for a in agents if a.name == winner)
        
        elif self.combination_mode == "cascade":
            # çº§è”æ¨¡å¼ï¼šä¾æ¬¡å°è¯•ç­–ç•¥
            for strategy in self.strategies:
                try:
                    return await strategy.select_agent(agents, history)
                except Exception:
                    continue
            
            return agents[0]  # é»˜è®¤é€‰æ‹©
```

---

## 6. å®é™…åº”ç”¨ç¤ºä¾‹

### 6.1 æ–‡æ¡£ç”Ÿæˆåœºæ™¯

```python
# 1. ä½¿ç”¨é¡ºåºé€‰æ‹©ç­–ç•¥
sequential_strategy = SequentialSelectionStrategy()

# 2. ä½¿ç”¨AIé©±åŠ¨é€‰æ‹©ç­–ç•¥
ai_strategy = CustomSelectionStrategy(
    chat_completion_service=AzureChatCompletion(
        deployment_name="gpt-4",
        endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
        api_key=os.getenv("AZURE_OPENAI_API_KEY")
    )
)

# 3. ä½¿ç”¨å‡½æ•°é€‰æ‹©ç­–ç•¥
@kernel_function(description="Select agent based on document creation workflow")
async def document_agent_selector(
    _agent_: Annotated[str, "Available agents"],
    _history_: Annotated[list, "Conversation history"]
) -> Annotated[str, "Selected agent name"]:
    """æ–‡æ¡£ç”Ÿæˆå·¥ä½œæµAgenté€‰æ‹©å™¨"""
    
    agents = _agent_.split(",")
    
    if not _history_:
        return "ContentCreationAgent"
    
    # åˆ†ææœ€åä¸€æ¡æ¶ˆæ¯
    last_message = _history_[-1]
    content = last_message.get("content", "").lower()
    
    # é€‰æ‹©é€»è¾‘
    if "```python" in content or "```" in content:
        return "CodeValidationAgent"
    elif "feedback" in content or "review" in content:
        return "UserAgent"
    elif "validation" in content and "passed" in content:
        return "UserAgent"
    else:
        return "ContentCreationAgent"

kernel = Kernel()
selection_function = KernelFunction.from_method(
    method=document_agent_selector,
    plugin_name="DocumentWorkflow"
)

function_strategy = KernelFunctionSelectionStrategy(
    function=selection_function,
    kernel=kernel,
    result_parser=lambda result: result.value
)

# 4. åœ¨AgentGroupChatä¸­ä½¿ç”¨
group_chat = AgentGroupChat(
    agents=[content_agent, code_agent, user_agent],
    selection_strategy=function_strategy,  # é€‰æ‹©ç­–ç•¥
    termination_strategy=custom_termination_strategy
)
```

### 6.2 å®¢æœç³»ç»Ÿåœºæ™¯

```python
# åŸºäºè§„åˆ™çš„é€‰æ‹©ç­–ç•¥
customer_service_rules = {
    "technical": "TechnicalSupportAgent",
    "billing": "BillingAgent",
    "complaint": "ComplaintHandlerAgent",
    "general": "GeneralSupportAgent"
}

rule_strategy = RuleBasedSelectionStrategy(customer_service_rules)

# ä¼˜å…ˆçº§é€‰æ‹©ç­–ç•¥
agent_priorities = {
    "EmergencyAgent": 1,
    "TechnicalSupportAgent": 2,
    "BillingAgent": 3,
    "GeneralSupportAgent": 4
}

priority_strategy = PrioritySelectionStrategy(agent_priorities)

# å¤åˆé€‰æ‹©ç­–ç•¥
composite_strategy = CompositeSelectionStrategy(
    strategies=[rule_strategy, priority_strategy],
    combination_mode="cascade"
)
```

### 6.3 ä»£ç å®¡æŸ¥åœºæ™¯

```python
# çŠ¶æ€æœºé€‰æ‹©ç­–ç•¥
code_review_states = {
    "start": {
        "code_submitted": "CodeReviewAgent",
        "question": "TechnicalAdvisorAgent"
    },
    "CodeReviewAgent": {
        "approved": "end",
        "needs_changes": "DeveloperAgent",
        "security_concern": "SecurityAgent"
    },
    "DeveloperAgent": {
        "updated": "CodeReviewAgent",
        "question": "TechnicalAdvisorAgent"
    },
    "SecurityAgent": {
        "cleared": "CodeReviewAgent",
        "blocked": "end"
    }
}

state_machine_strategy = StateMachineSelectionStrategy(code_review_states)
```

---

## 7. æ€»ç»“

### 7.1 Semantic Kernel çš„ä¼˜åŠ¿

1. **é«˜åº¦å¯å®šåˆ¶åŒ–**ï¼šKernelFunctionSelectionStrategy æä¾›äº†æ— é™çš„å¯èƒ½æ€§
2. **AIåŸç”Ÿè®¾è®¡**ï¼šCustomSelectionStrategy å±•ç¤ºäº†AIé©±åŠ¨é€‰æ‹©çš„å¼ºå¤§èƒ½åŠ›
3. **æ¶æ„ä¼˜é›…**ï¼šåŸºäºæŠ½è±¡ç±»çš„è®¾è®¡ï¼Œæ˜“äºæ‰©å±•
4. **é›†æˆè‰¯å¥½**ï¼šä¸Kernelå‡½æ•°ç”Ÿæ€ç³»ç»Ÿå®Œç¾èåˆ

### 7.2 æ”¹è¿›ç©ºé—´

1. **å¢åŠ å†…ç½®ç­–ç•¥**ï¼šæä¾›æ›´å¤šå¼€ç®±å³ç”¨çš„é€‰æ‹©ç­–ç•¥
2. **æä¾›ç­–ç•¥æ¨¡æ¿**ï¼šä¸ºå¸¸è§åœºæ™¯æä¾›ä»£ç æ¨¡æ¿
3. **æ”¹è¿›æ–‡æ¡£**ï¼šæä¾›æ›´å¤šç¤ºä¾‹å’Œæœ€ä½³å®è·µ
4. **ç­–ç•¥ç»„åˆ**ï¼šæ”¯æŒå¤šä¸ªç­–ç•¥çš„ç»„åˆä½¿ç”¨
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šæä¾›ç¼“å­˜å’Œä¼˜åŒ–æœºåˆ¶

### 7.3 å‘å±•æ–¹å‘

1. **æ™ºèƒ½åŒ–ç¨‹åº¦æå‡**ï¼šæ›´å¤šåŸºäºAIçš„é€‰æ‹©ç­–ç•¥
2. **åœºæ™¯åŒ–æ¨¡æ¿**ï¼šé’ˆå¯¹ç‰¹å®šä¸šåŠ¡åœºæ™¯çš„ä¸“ç”¨ç­–ç•¥
3. **å¯è§†åŒ–å·¥å…·**ï¼šæä¾›ç­–ç•¥é…ç½®å’Œè°ƒè¯•å·¥å…·
4. **æ€§èƒ½ç›‘æ§**ï¼šæ·»åŠ é€‰æ‹©ç­–ç•¥çš„æ€§èƒ½ç›‘æ§å’Œåˆ†æ
5. **ç¤¾åŒºè´¡çŒ®**ï¼šé¼“åŠ±ç¤¾åŒºè´¡çŒ®æ›´å¤šé€‰æ‹©ç­–ç•¥

### 7.4 æœ€ä½³å®è·µå»ºè®®

1. **ç®€å•åœºæ™¯**ï¼šä½¿ç”¨ `SequentialSelectionStrategy`
2. **å¤æ‚ä¸šåŠ¡é€»è¾‘**ï¼šä½¿ç”¨ `KernelFunctionSelectionStrategy`
3. **æ™ºèƒ½é€‰æ‹©**ï¼šä½¿ç”¨ `CustomSelectionStrategy`
4. **æ··åˆä½¿ç”¨**ï¼šç»“åˆå¤šç§ç­–ç•¥ä»¥é€‚åº”ä¸åŒåœºæ™¯
5. **æ€§èƒ½è€ƒè™‘**ï¼šæ ¹æ®å®é™…éœ€æ±‚å¹³è¡¡æ™ºèƒ½æ€§å’Œæ€§èƒ½

é€šè¿‡å¯¹æ¯”åˆ†æï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ° Semantic Kernel åœ¨é€‰æ‹©ç­–ç•¥æ–¹é¢å…·æœ‰ç‹¬ç‰¹çš„ä¼˜åŠ¿ï¼Œç‰¹åˆ«æ˜¯åœ¨å¯å®šåˆ¶æ€§å’ŒAIé›†æˆæ–¹é¢ã€‚ä½†åŒæ—¶ä¹Ÿéœ€è¦åœ¨å¼€ç®±å³ç”¨çš„ä¾¿åˆ©æ€§æ–¹é¢è¿›è¡Œæ”¹è¿›ï¼Œä»¥é™ä½ä½¿ç”¨é—¨æ§›ï¼Œæé«˜å¼€å‘æ•ˆç‡ã€‚

---

*æœ¬æ–‡æ¡£æœ€åæ›´æ–°æ—¶é—´ï¼š2025å¹´7æœˆ8æ—¥*
