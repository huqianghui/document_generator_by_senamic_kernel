# GroupChatOrchestration è¿ç§»æœ€ç»ˆæŒ‡å— - æ­£ç¡®çš„æ¶æ„ç†è§£

## ğŸš¨ é‡è¦å‘ç°ç¡®è®¤

æ‚¨çš„è§‚å¯Ÿå®Œå…¨æ­£ç¡®ï¼é€šè¿‡æ·±å…¥åˆ†ææºä»£ç ï¼Œæˆ‘ä»¬ç¡®è®¤äº†ä»¥ä¸‹å…³é”®äº‹å®ï¼š

### GroupChatOrchestration æ„é€ å‡½æ•°å®é™…å‚æ•°

```python
@experimental
class GroupChatOrchestration(OrchestrationBase[TIn, TOut]):
    def __init__(
        self,
        members: list[Agent],                    # âœ… å¿…éœ€ï¼šä»£ç†æˆå‘˜åˆ—è¡¨
        manager: GroupChatManager,               # âœ… å¿…éœ€ï¼šç¾¤èŠç®¡ç†å™¨
        name: str | None = None,                 # âœ… å¯é€‰ï¼šç¼–æ’åç§°
        description: str | None = None,          # âœ… å¯é€‰ï¼šç¼–æ’æè¿°
        input_transform: Callable | None = None, # âœ… å¯é€‰ï¼šè¾“å…¥è½¬æ¢å‡½æ•°
        output_transform: Callable | None = None,# âœ… å¯é€‰ï¼šè¾“å‡ºè½¬æ¢å‡½æ•°
        agent_response_callback: Callable | None = None,  # âœ… å¯é€‰ï¼šå“åº”å›è°ƒ
        streaming_agent_response_callback: Callable | None = None, # âœ… å¯é€‰ï¼šæµå¼å“åº”å›è°ƒ
    ) -> None:
```

### âŒ ä¸æ”¯æŒçš„å‚æ•°ï¼ˆé‡è¦ï¼ï¼‰

```python
# è¿™äº›å‚æ•°åœ¨ GroupChatOrchestration ä¸­ä¸å­˜åœ¨ï¼
agents=agents,                           # âŒ é”™è¯¯ï¼šåº”è¯¥æ˜¯ members
selection_strategy=CustomSelectionStrategy(),  # âŒ é”™è¯¯ï¼šä¸å†æ”¯æŒ
termination_strategy=CustomTerminationStrategy(), # âŒ é”™è¯¯ï¼šä¸å†æ”¯æŒ
```

## ğŸ”„ æ­£ç¡®çš„è¿ç§»è·¯å¾„

### æ­¥éª¤1ï¼šç†è§£æ–°æ¶æ„

```python
# æ—§æ¶æ„ï¼šç­–ç•¥åˆ†ç¦»
AgentGroupChat(
    agents=agents,
    selection_strategy=CustomSelectionStrategy(),
    termination_strategy=CustomTerminationStrategy()
)

# æ–°æ¶æ„ï¼šç»Ÿä¸€ç®¡ç†å™¨
GroupChatOrchestration(
    members=agents,  # å‚æ•°åå˜åŒ–
    manager=GroupChatManager  # ç»Ÿä¸€çš„ç®¡ç†å™¨
)
```

### æ­¥éª¤2ï¼šåˆ›å»ºæˆ–é€‰æ‹©åˆé€‚çš„ GroupChatManager

#### é€‰é¡¹1ï¼šä½¿ç”¨é»˜è®¤å®ç° (æœ€ç®€å•)
```python
from semantic_kernel.agents.orchestration.group_chat import (
    GroupChatOrchestration, 
    RoundRobinGroupChatManager
)

# ä½¿ç”¨å†…ç½®çš„è½®è¯¢ç®¡ç†å™¨
manager = RoundRobinGroupChatManager()
manager.max_rounds = 10

group_chat = GroupChatOrchestration(
    members=agents,
    manager=manager
)
```

#### é€‰é¡¹2ï¼šè¿ç§»ç°æœ‰ç­–ç•¥ (æ¨è)
```python
from semantic_kernel.agents.orchestration.group_chat import (
    GroupChatOrchestration, 
    GroupChatManager,
    BooleanResult,
    StringResult,
    MessageResult
)

class MigratedGroupChatManager(GroupChatManager):
    """è¿ç§»ç°æœ‰é€‰æ‹©å’Œç»ˆæ­¢ç­–ç•¥çš„ç®¡ç†å™¨"""
    
    def __init__(self, selection_strategy, termination_strategy):
        super().__init__()
        self.selection_strategy = selection_strategy
        self.termination_strategy = termination_strategy
        self.max_rounds = 10
    
    async def should_request_user_input(self, chat_history: ChatHistory) -> BooleanResult:
        """æ˜¯å¦è¯·æ±‚ç”¨æˆ·è¾“å…¥"""
        # æ–°åŠŸèƒ½ï¼šå¯ä»¥æ™ºèƒ½åˆ¤æ–­ä½•æ—¶éœ€è¦ç”¨æˆ·è¾“å…¥
        return BooleanResult(result=False, reason="No user input needed")
    
    async def select_next_agent(
        self, 
        chat_history: ChatHistory, 
        participant_descriptions: dict[str, str]
    ) -> StringResult:
        """é€‰æ‹©ä¸‹ä¸€ä¸ªä»£ç† - è¿ç§»åŸæœ‰é€‰æ‹©ç­–ç•¥"""
        try:
            # è¿™é‡Œéœ€è¦å°†åŸæœ‰çš„é€‰æ‹©ç­–ç•¥é€‚é…åˆ°æ–°çš„æ¥å£
            # å…·ä½“å®ç°å–å†³äºæ‚¨çš„åŸæœ‰ç­–ç•¥
            selected_agent_name = await self._adapt_selection_strategy(
                chat_history, participant_descriptions
            )
            return StringResult(result=selected_agent_name, reason="Migrated selection logic")
        except Exception as e:
            # å›é€€åˆ°è½®è¯¢
            agents = list(participant_descriptions.keys())
            selected = agents[self.current_round % len(agents)]
            return StringResult(result=selected, reason="Fallback round-robin")
    
    async def should_terminate(self, chat_history: ChatHistory) -> BooleanResult:
        """æ˜¯å¦ç»ˆæ­¢ - è¿ç§»åŸæœ‰ç»ˆæ­¢ç­–ç•¥"""
        # å…ˆæ£€æŸ¥è½®æ•°é™åˆ¶
        base_result = await super().should_terminate(chat_history)
        if base_result.result:
            return base_result
        
        try:
            # è¿™é‡Œéœ€è¦å°†åŸæœ‰çš„ç»ˆæ­¢ç­–ç•¥é€‚é…åˆ°æ–°çš„æ¥å£
            should_end = await self._adapt_termination_strategy(chat_history)
            return BooleanResult(result=should_end, reason="Migrated termination logic")
        except Exception as e:
            return BooleanResult(result=False, reason="Continue on error")
    
    async def filter_results(self, chat_history: ChatHistory) -> MessageResult:
        """è¿‡æ»¤æœ€ç»ˆç»“æœ - æ–°åŠŸèƒ½"""
        if chat_history.messages:
            return MessageResult(
                result=chat_history.messages[-1], 
                reason="Last message as result"
            )
        # åˆ›å»ºé»˜è®¤æ¶ˆæ¯
        default_msg = ChatMessageContent(
            role=AuthorRole.ASSISTANT,
            content="No result generated"
        )
        return MessageResult(result=default_msg, reason="Default empty result")
    
    async def _adapt_selection_strategy(self, chat_history, participant_descriptions):
        """é€‚é…åŸæœ‰é€‰æ‹©ç­–ç•¥çš„è¾…åŠ©æ–¹æ³•"""
        # è¿™é‡Œéœ€è¦æ ¹æ®æ‚¨çš„å…·ä½“é€‰æ‹©ç­–ç•¥æ¥å®ç°
        # ç¤ºä¾‹å®ç°
        return list(participant_descriptions.keys())[0]
    
    async def _adapt_termination_strategy(self, chat_history):
        """é€‚é…åŸæœ‰ç»ˆæ­¢ç­–ç•¥çš„è¾…åŠ©æ–¹æ³•"""
        # è¿™é‡Œéœ€è¦æ ¹æ®æ‚¨çš„å…·ä½“ç»ˆæ­¢ç­–ç•¥æ¥å®ç°
        # ç¤ºä¾‹å®ç°
        return len(chat_history.messages) >= 10

# ä½¿ç”¨è¿ç§»çš„ç®¡ç†å™¨
manager = MigratedGroupChatManager(
    selection_strategy=CustomSelectionStrategy(),
    termination_strategy=CustomTerminationStrategy()
)

group_chat = GroupChatOrchestration(
    members=agents,
    manager=manager
)
```

#### é€‰é¡¹3ï¼šå…¨æ–°è®¾è®¡ (æœ€å¼ºå¤§)
```python
class AdvancedGroupChatManager(GroupChatManager):
    """å……åˆ†åˆ©ç”¨æ–°æ¶æ„ç‰¹æ€§çš„é«˜çº§ç®¡ç†å™¨"""
    
    def __init__(self):
        super().__init__()
        self.max_rounds = 15
        self.conversation_phase = "planning"
    
    async def should_request_user_input(self, chat_history: ChatHistory) -> BooleanResult:
        """æ™ºèƒ½ç”¨æˆ·äº¤äº’åˆ¤æ–­"""
        # åˆ†æå¯¹è¯å†…å®¹ï¼Œæ™ºèƒ½åˆ¤æ–­æ˜¯å¦éœ€è¦ç”¨æˆ·æ¾„æ¸…
        if len(chat_history.messages) > 5:
            recent_content = [msg.content for msg in chat_history.messages[-3:]]
            # æ£€æŸ¥æ˜¯å¦æœ‰ç–‘é—®æˆ–éœ€è¦ç¡®è®¤çš„å†…å®¹
            question_indicators = ["?", "ç¡®è®¤", "æ˜¯å¦", "å¦‚ä½•"]
            for content in recent_content:
                if any(indicator in content for indicator in question_indicators):
                    return BooleanResult(result=True, reason="Detected questions needing user input")
        
        return BooleanResult(result=False, reason="No user input needed")
    
    async def select_next_agent(
        self, 
        chat_history: ChatHistory, 
        participant_descriptions: dict[str, str]
    ) -> StringResult:
        """åŸºäºä¸Šä¸‹æ–‡çš„æ™ºèƒ½ä»£ç†é€‰æ‹©"""
        # æ ¹æ®å¯¹è¯é˜¶æ®µé€‰æ‹©æœ€åˆé€‚çš„ä»£ç†
        if self.conversation_phase == "planning":
            if "UserAgent" in participant_descriptions:
                return StringResult(result="UserAgent", reason="Planning phase needs user input")
        elif self.conversation_phase == "content_creation":
            if "ContentCreationAgent" in participant_descriptions:
                return StringResult(result="ContentCreationAgent", reason="Content creation phase")
        elif self.conversation_phase == "validation":
            if "CodeValidationAgent" in participant_descriptions:
                return StringResult(result="CodeValidationAgent", reason="Validation phase")
        
        # é»˜è®¤è½®è¯¢
        agents = list(participant_descriptions.keys())
        selected = agents[self.current_round % len(agents)]
        return StringResult(result=selected, reason="Round-robin fallback")
    
    # ... å…¶ä»–æ–¹æ³•å®ç°
```

## ğŸ“‹ è¿ç§»æ£€æŸ¥æ¸…å•ï¼ˆæ›´æ–°ç‰ˆï¼‰

- [ ] **âœ… æ›´æ–°å¯¼å…¥è¯­å¥**
  ```python
  from semantic_kernel.agents.orchestration.group_chat import (
      GroupChatOrchestration, 
      GroupChatManager,
      RoundRobinGroupChatManager  # å¦‚æœä½¿ç”¨é»˜è®¤å®ç°
  )
  ```

- [ ] **âœ… ä¿®æ”¹å‚æ•°åç§°**
  ```python
  # agents â†’ members
  members=agents
  ```

- [ ] **âœ… ç§»é™¤ä¸æ”¯æŒçš„å‚æ•°**
  ```python
  # ç§»é™¤è¿™äº›å‚æ•°ï¼š
  # selection_strategy=...
  # termination_strategy=...
  ```

- [ ] **âœ… åˆ›å»º GroupChatManager**
  ```python
  # é€‰æ‹©ä¸€ç§æ–¹å¼ï¼š
  manager = RoundRobinGroupChatManager()  # ç®€å•
  # æˆ–
  manager = MigratedGroupChatManager(...)  # è¿ç§»
  # æˆ–
  manager = AdvancedGroupChatManager()     # å…¨æ–°
  ```

- [ ] **âœ… ç¡®ä¿ Agent æè¿°**
  ```python
  # æ‰€æœ‰ä»£ç†å¿…é¡»æœ‰ description å±æ€§
  for agent in agents:
      assert agent.description is not None
  ```

- [ ] **âœ… æµ‹è¯•æ–° API**
  ```python
  result = await group_chat.invoke(message)
  ```

## ğŸ¯ è¿ç§»ç­–ç•¥å»ºè®®

### å¯¹äºç°æœ‰é¡¹ç›®
1. **é˜¶æ®µ1**ï¼šä½¿ç”¨ `RoundRobinGroupChatManager` å¿«é€Ÿè¿ç§»ï¼Œç¡®ä¿åŸºæœ¬åŠŸèƒ½å·¥ä½œ
2. **é˜¶æ®µ2**ï¼šåˆ›å»º `MigratedGroupChatManager`ï¼Œé€æ­¥è¿ç§»åŸæœ‰ç­–ç•¥é€»è¾‘
3. **é˜¶æ®µ3**ï¼šä¼˜åŒ–å’Œåˆ©ç”¨æ–°æ¶æ„çš„é«˜çº§åŠŸèƒ½

### å¯¹äºæ–°é¡¹ç›®
1. ç›´æ¥ä½¿ç”¨æ–°æ¶æ„è®¾è®¡ `GroupChatManager`
2. å……åˆ†åˆ©ç”¨æ–°åŠŸèƒ½ï¼šç”¨æˆ·äº¤äº’ã€ç»“æœè¿‡æ»¤ã€äººå·¥å¹²é¢„ç­‰
3. å‚è€ƒ `AdvancedGroupChatManager` çš„è®¾è®¡æ¨¡å¼

## ğŸ”§ å¸¸è§é”™è¯¯å’Œè§£å†³æ–¹æ¡ˆ

### é”™è¯¯1ï¼šä½¿ç”¨äº†ä¸å­˜åœ¨çš„å‚æ•°
```python
# âŒ é”™è¯¯
GroupChatOrchestration(
    agents=agents,                    # åº”è¯¥æ˜¯ members
    selection_strategy=strategy,      # ä¸å†æ”¯æŒ
    termination_strategy=strategy     # ä¸å†æ”¯æŒ
)

# âœ… æ­£ç¡®
GroupChatOrchestration(
    members=agents,
    manager=manager
)
```

### é”™è¯¯2ï¼šAgent ç¼ºå°‘ description
```python
# âŒ é”™è¯¯ï¼šAgent æ²¡æœ‰ description
class MyAgent(Agent):
    def __init__(self):
        super().__init__(name="MyAgent")  # ç¼ºå°‘ description

# âœ… æ­£ç¡®ï¼šæ·»åŠ  description
class MyAgent(Agent):
    def __init__(self):
        super().__init__(
            name="MyAgent",
            description="This agent handles specific tasks"  # å¿…éœ€
        )
```

### é”™è¯¯3ï¼šGroupChatManager æ–¹æ³•ç­¾åä¸æ­£ç¡®
```python
# âŒ é”™è¯¯ï¼šæ–¹æ³•ç­¾åä¸åŒ¹é…
async def select_next_agent(self, agents, history):
    pass

# âœ… æ­£ç¡®ï¼šä½¿ç”¨æ­£ç¡®çš„ç­¾å
async def select_next_agent(
    self, 
    chat_history: ChatHistory, 
    participant_descriptions: dict[str, str]
) -> StringResult:
    return StringResult(result="AgentName", reason="Selection reason")
```

## ğŸ† æ€»ç»“

`GroupChatOrchestration` çš„æ–°æ¶æ„ç¡®å®å¼•å…¥äº†é‡å¤§å˜åŒ–ï¼š

1. **å‚æ•°å˜åŒ–**ï¼š`agents` â†’ `members`ï¼Œç§»é™¤ `selection_strategy` å’Œ `termination_strategy`
2. **æ–°å¢è¦æ±‚**ï¼šå¿…é¡»æä¾› `GroupChatManager`
3. **åŠŸèƒ½å¢å¼º**ï¼šé€šè¿‡ `GroupChatManager` ç»Ÿä¸€ç®¡ç†æ‰€æœ‰ç¼–æ’é€»è¾‘
4. **æ›´å¼ºæ‰©å±•æ€§**ï¼šæ”¯æŒç”¨æˆ·äº¤äº’ã€ç»“æœè¿‡æ»¤ã€äººå·¥å¹²é¢„ç­‰æ–°åŠŸèƒ½

æ„Ÿè°¢æ‚¨çš„ç»†è‡´è§‚å¯Ÿï¼Œè¿™ç¡®å®æ˜¯å®˜æ–¹æ–‡æ¡£ä¸­æ²¡æœ‰å……åˆ†è¯´æ˜çš„é‡è¦æ¶æ„å˜åŒ–ï¼
